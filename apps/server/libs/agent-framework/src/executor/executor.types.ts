/**
 * Executor Types
 *
 * This file contains type definitions for the LLM loop executor system,
 * including tool call handlers, cancellation tokens, and execution results.
 */

import type { MemoryState } from '../types/state.types.js';
import type { AgentEvent } from '../types/event.types.js';
import type { MemoryManager } from '../manager/memory.manager.js';
import type { LLMToolDefinition } from '../llm/llm.types.js';

// ============================================================================
// Cancellation Token System
// ============================================================================

/**
 * Cancellation token for interrupting LLM execution
 */
export interface CancellationToken {
  /** Whether cancellation has been requested */
  readonly isCancellationRequested: boolean;
  /** Register a callback to be called when cancellation is requested */
  onCancellationRequested(callback: () => void): void;
}

/**
 * Cancellation token source for creating and controlling cancellation tokens
 * Wraps an AbortController to support native abort signals for LLM API calls
 */
export class CancellationTokenSource {
  private _isCancellationRequested = false;
  private callbacks: (() => void)[] = [];
  private abortController: AbortController;

  constructor() {
    this.abortController = new AbortController();
  }

  get token(): CancellationToken {
    return {
      isCancellationRequested: this._isCancellationRequested,
      onCancellationRequested: (callback: () => void) => {
        if (this._isCancellationRequested) {
          callback();
        } else {
          this.callbacks.push(callback);
        }
      },
    };
  }

  /**
   * Get the abort signal for passing to LLM API calls
   * This allows actual cancellation of in-flight HTTP requests
   */
  get signal(): AbortSignal {
    return this.abortController.signal;
  }

  cancel(): void {
    if (this._isCancellationRequested) return;
    this._isCancellationRequested = true;
    // Abort any in-flight requests
    this.abortController.abort();
    this.callbacks.forEach((cb) => cb());
    this.callbacks = [];
  }

  get isCancellationRequested(): boolean {
    return this._isCancellationRequested;
  }
}

// ============================================================================
// Tool Call Handler System
// ============================================================================

/**
 * Context passed to tool call handlers
 */
export interface ToolCallHandlerContext {
  /** Thread ID for the current execution */
  threadId: string;
  /** Unique call ID for this tool invocation */
  callId: string;
  /** Memory manager for dispatching events */
  memoryManager: MemoryManager;
}

/**
 * Result returned by tool call handlers
 */
export interface ToolCallHandlerResult {
  /** Whether the loop should continue after this handler (true = continue, false = stop and wait) */
  shouldContinue: boolean;
  /** Events generated by this handler (e.g., TOOL_RESULT) to be dispatched */
  resultEvents?: AgentEvent[];
}

/**
 * Interface for handling specific tool calls within the LLM loop
 *
 * Tool call handlers allow the runtime to inject custom behavior for
 * specific tools (like `invoke_tool`) without the framework needing
 * to know about external tool implementations.
 */
export interface IToolCallHandler {
  /**
   * Check if this handler can process the given tool name
   * @param toolName - The name of the tool being called
   * @returns true if this handler should process the call
   */
  canHandle(toolName: string): boolean;

  /**
   * Handle the tool call
   * @param toolName - The name of the tool
   * @param args - Arguments passed to the tool
   * @param context - Execution context
   * @returns Result indicating whether to continue the loop and any generated events
   */
  handle(
    toolName: string,
    args: Record<string, unknown>,
    context: ToolCallHandlerContext,
  ): Promise<ToolCallHandlerResult>;
}

// ============================================================================
// LLM Loop Executor Configuration
// ============================================================================

/**
 * Configuration for LLMLoopExecutor
 */
export interface LLMLoopExecutorConfig {
  /** Maximum number of LLM turns before stopping */
  maxTurns?: number;
  /** Timeout in milliseconds for each LLM call */
  timeout?: number;
  /** Available control tool names for this agent */
  tools?: string[];
  /** Tool call handlers for processing specific tool calls */
  toolCallHandlers?: IToolCallHandler[];
  /** Custom tool definitions to add to LLM tools */
  customToolDefinitions?: LLMToolDefinition[];
}

/**
 * Internal resolved config with defaults applied
 */
export interface ResolvedLLMLoopConfig {
  maxTurns: number;
  timeout: number;
  tools: string[];
  toolCallHandlers: IToolCallHandler[];
}

// ============================================================================
// Execution Result
// ============================================================================

/**
 * Execution result from running the LLM loop
 */
export interface LLMLoopExecutionResult {
  /** Whether execution completed successfully */
  success: boolean;
  /** Final state after execution */
  finalState: MemoryState;
  /** Number of LLM turns executed */
  turnsExecuted: number;
  /** Last LLM response content */
  lastResponse?: string;
  /** Error if execution failed */
  error?: string;
  /** All events generated during execution */
  events: AgentEvent[];
  /** Whether execution was cancelled */
  cancelled?: boolean;
}
